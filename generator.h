/*
 * generator.h
 *
 *  Created on: 08.12.2011
 *      Author: marscher
 */

#ifndef GENERATOR_H_
#define GENERATOR_H_

#include "common_typedefs.h"
#include "rotation_matrix.h"

namespace tkdGenerator {

const static vector3 origin(0, 0, 0);

/**
 * generates domain decomposition of tetrakaidecahedron.
 * After calling createDomain() you can get the positions and indices
 * of the created geometries to create a Grid object
 */
class TKDGeometryGenerator {

public:
	void createDomain();

	/**
	 * @param height
	 * @param baseEdgeLength
	 * @param diameter
	 * @param d_lipid
	 */
	TKDGeometryGenerator(number height, number baseEdgeLength, number diameter,
			number d_lipid);

	number getVolume() const;
	number getVolume(number a, number s, number h) const;
	number getSurface() const;
	number getSurface(number a, number s, number h) const;
	const IndexArray& getIndices() const;
	const CoordsArray& getPositions() const;
	number getHeight() const;
	number getOverlap() const;

protected:
	/**
	 * number of vertices of used solid figures
	 */
	enum SolidFigures {
		Tetrahedron = 4, Pyramid = 5, Prism = 6, Hexahedron = 8
	};

	// height of one third of tkd : h = 1/3 * h_tkd
	number h_corneocyte;
	// base edge length of central hexahedron
	number a_corneocyte;
	// diameter
	number w_corneocyte;
	number s_corneocyte;
	// thickness of lipid matrix
	number d_lipid;
	// base edge length of lipid matrix
	number a_lipid;
	// height of 1/3 of lipid matrix
	number h_lipid;
	// quantity s, overlap of two aligned tkds with lipid matrix
	number s_lipid;

	/**
	 * stores coordinates of points
	 */
	CoordsArray posOut;

	/**
	 * stores indices for points
	 */
	IndexArray indsOut;

	// matrix used to rotate all geometric objects around z axis
	RotationMatrix R;

	// global index which is incremented for all vertices generated by this instance
	size_t index;

	/**
	 * inits base geometric parameters
	 */
	void initGeometricParams();

	void createCorneocyte(const vector3&);
	void createLipidMatrix(const vector3&, const number rotationOffset = 0,
			bool bottom = false);

	/**
	 *	creates the upper part of tkd (symmetric to bottom part!)
	 */
	void createCorneocyteTop(const vector3& offset,
			const number rotationOffset = 0, bool bottom = false);

	/**
	 * creates middle part with given offset
	 */
	void createCorneocyteMiddle(const vector3& offset);

	/**
	 * pushes posIn into global posOut reference and creates
	 * indices for each vertex which are pushed into global indsOut reference
	 */
	void createGeometricObject(const CoordsArray& posIn);

	void flipOrientationPrism(CoordsArray& prismPos);
	void flipOrientationPyramid(CoordsArray& pyramidPos);
	void flipOrientationTetrahedron(CoordsArray& tetrahedronPos);
	void flipOrientationHexahedron(CoordsArray& hexaPos);

	///// segments of top and bottom
	CoordsArray obenInnen;
	// G(Ki -> ObenAussenPr)
	CoordsArray obenAussenPrism;

	CoordsArray obenAussenPr_rightTetrahedron;
	CoordsArray obenAussenPr_leftTetrahedron;
	CoordsArray obenAussenPr2T_prism;

	///// segments of middle part
	// outer prism
	CoordsArray mitteAussenP1;
	// inner prism
	CoordsArray mitteAussenP2;

	// below obenAussenPr_rightTetrahedron
	CoordsArray mitteAussenH2Pr_tetrahedron;
	CoordsArray mitteAussenH2Pr_pyramid;

	CoordsArray mitteAussen2PrH_tetrahedron;
	CoordsArray mitteAussen2PrH_pyramid;

	// below obenAussenPrism
	CoordsArray mitteAussenHexahedron;

	// lipid matrix
	/// lipid hexagon
	CoordsArray obenInnenPrismL;
	CoordsArray obenAussenPrismL;
	CoordsArray obenAussen_leftPrismL;
	CoordsArray obenAussen_rightPrismL;
	CoordsArray upperHexahedronL;
	CoordsArray bottomOuterHexahedronL;
	CoordsArray bottomLeftPrismL;
	CoordsArray bottomRightPrismL;

	// lipid side quad
	CoordsArray sideQuad;
	int count;
};

} //end of namespace
#endif /* GENERATOR_H_ */
